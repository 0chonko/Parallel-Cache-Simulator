READ
	P1 requests data at 0000
	
	C1 miss read 
		- send bus mem request from memory
		- waits 100ns for the result
		- evicts if anything to evict
		- sends data to CPU
		- issues NW
	
	C1 hit read 
		- check for validity 
		- if invalid retrieve memory 
		- set to valid 
		- send to CPU

WRITE
	P1 writes data at 0000
	
	C1 miss write 
		- send bus mem request from memory
		- waits 100ns for the result
		- evicts if anything to evict
		- sends data to CPU
		- broadcasts invalidation bit to the bus 

	
	C1 hit write 
		- update value 
		- broadcast invalidation to the bus for 0000
		- write-through to memory (wait to complete)
		- 
		

Snooping protocol
State transitions
	Stay invalid 
		- recv NR, NW, PW (issue NW)
	Stay valid
		- recv PR, NR, PW (issue NW)
	Go  invalid
		- recv NW
	Go valid
		- Recv PR (issue NR)
		
		
		
################################
void execute() {
        while (true) {
            wait(Port_Func.value_changed_event());
            Function f = Port_Func.read();
            uint64_t addr = Port_Addr.read();
            uint64_t data = 0;
            uint32_t ret_data = 0; // for return data
            uint64_t setIndex = (addr >> BLOCK_OFFSET_BITS) & setIndexMask;
            uint64_t blockOffset = addr & blockOffsetMask;
            uint64_t tag = addr >> (SET_INDEX_BITS + BLOCK_OFFSET_BITS);

            if (f == FUNC_WRITE) {  
                if(debug) cout << sc_time_stamp() << ": MEM received write" << endl;
                bool tagMatch = false;
                data = Port_Data.read().to_uint64();
                for (uint64_t i = 0; i < SET_SIZE; i++) {
                    if (cache[setIndex].lines[i].tag == tag && cache[setIndex].lines[i].state == 1) {
                        if(debug) cout << sc_time_stamp() << ": MEM received write hit" << endl;
                        stats_writehit(0);
                        tagMatch = true;
                        cache[setIndex].lines[i].data[blockOffset] = data;
                        cache[setIndex].lines[i].tag = tag;
                        update_aging_bits(setIndex, i);
                        break;
                    }
                }
                if (!tagMatch) {
                    if(debug) cout << sc_time_stamp() << ": MEM received write miss" << endl;
                    stats_writemiss(0);
                    int oldest = find_oldest(setIndex);
                    wait(100);
                    if (cache[setIndex].lines[oldest].dirty) cache[setIndex].lines[oldest].dirty = 0;
                    if (oldest == 0) oldest = 1;
                    cache[setIndex].lines[oldest].state = 1;
                    cache[setIndex].lines[oldest].tag = tag;
                    cache[setIndex].lines[oldest].data[blockOffset] = data;
                    cache[setIndex].lines[oldest].dirty = 1;
                    update_aging_bits(setIndex, oldest);
                }
                wait(1);
            } else {
                if(debug) cout << sc_time_stamp() << ": MEM received read" << endl;
                bool tagMatch = false;
                for (uint64_t i = 0; i < SET_SIZE; i++) {
                    if (cache[setIndex].lines[i].tag == tag && cache[setIndex].lines[i].state == 1) {
                        if(debug) cout << sc_time_stamp() << ": MEM received read hit" << endl;
                        stats_readhit(0);
                        tagMatch = true;
                        ret_data = cache[setIndex].lines[i].data[blockOffset];
                        cache[setIndex].lines[i].tag = tag;
                        update_aging_bits(setIndex, i);
                        break;
                    }
                }
                if (!tagMatch) {
                    if(debug) cout << sc_time_stamp() << ": MEM received read miss" << endl;
                    stats_readmiss(0);
                    int oldest = find_oldest(setIndex);
                    if (cache[setIndex].lines[oldest].dirty)
                    {   
                        if(debug) cout << sc_time_stamp() << ": MEM received read miss with dirty, writing back" << endl;
                        cache[setIndex].lines[oldest].dirty = 0;
                    }
                    wait(100);
                    if (oldest == 0) 
                    {
                        if(debug) cout << sc_time_stamp() << ": MEM received read on a empty line" << endl;
                        oldest = 1;
                    }
                    cache[setIndex].lines[oldest].state = 1;
                    cache[setIndex].lines[oldest].tag = tag;
                    ret_data = cache[setIndex].lines[oldest].data[blockOffset];
                    update_aging_bits(setIndex, oldest);
                }
                wait(1);
            }
            if(debug) cout << sc_time_stamp() << ": MEM address " << addr << endl;
            if (f == FUNC_READ) {
                Port_Data.write((addr < CACHE_SIZE) ? ret_data : 0);
                Port_Done.write(RET_READ_DONE);
                wait();
                Port_Data.write(float_64_bit_wire);
            } else {
                Port_Done.write(RET_WRITE_DONE);
            }
